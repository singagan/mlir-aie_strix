<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'AIE' Dialect

This is a dialect for describing netlists of AIE components in a
Versal device.  It focuses on representing logical stream connections
between cores and DMAs, along with the implementation of those logical
connections in the various switch components.  In the dialect, a
switch is referred to as 'switchbox' to avoid confusion with the
'switch' keyword in C/C++.


[TOC]

## Operation definition

### `AIE.amsel` (::xilinx::AIE::AMSelOp)

Declare an arbiter of a switchbox with a master select value (arbiter + msel)


Syntax:

```
operation ::= `AIE.amsel` `<` $arbiterID `>` `(` $msel `)` attr-dict
```

A combination of arbiter ID and master select (msel) value.
This op is used as a pointer to select the arbiter for routing a packet-switched flow

Example:
```
    %a0_0 = AIE.amsel<5>(3)
    %m1 = AIE.masterset("East" : 0, %a0_0 )
    AIE.packetrules("South" : 0) {
      AIE.rule(0x1F, 0x10, %a0_0)
    }
```
This code associates arbiter 5 with msel=3.  A packet-switched connection is made routing
traffic from the South:0 port to the East:0 port using this arbiter.
There are 6 arbiters per switchbox and 4 possible master select values.
See also [MasterSetOp](#aiemasterset-aiemastersetop),
[PacketRulesOp](#aiepacketrules-aiepacketrulesop), and
[PacketRuleOp](#aierule-aiepacketruleop) for more information.

Traits: HasParent<SwitchboxOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `arbiterID` | ::mlir::IntegerAttr | 8-bit signless integer attribute whose minimum value is 0 whose maximum value is 5
| `msel` | ::mlir::IntegerAttr | 8-bit signless integer attribute whose minimum value is 0 whose maximum value is 3

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.buffer` (::xilinx::AIE::BufferOp)

Declare a buffer


Syntax:

```
operation ::= `AIE.buffer` `(` $tile `)` attr-dict `:` type($buffer)
```

This operation instantiates a buffer that belongs to a Memory Module of a tile.

Example:
```
  %tile33 = AIE.tile(3, 3)
  %buf = AIE.buffer(%tile33) : memref<256xi64>
```
This operation represents a buffer in tile (3, 3) of 256 elements, each a 64-bit integer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
| `buffer` | memref of any type values

### `AIE.connect` (::xilinx::AIE::ConnectOp)

A circuit-switched connection inside a switchbox


Syntax:

```
operation ::= `AIE.connect` `<` $sourceBundle `:` $sourceChannel `,` $destBundle `:` $destChannel `>` attr-dict
```

This operation represents a programmed circuit-switched connection in a stream switch.
It associates a source bundle and source channel with a destination bundle and a destination channel.
This operation must exist within an "aie.switchbox" or "aie.shimswitchbox" operation.
All of the "aie.connect" operations in a switchbox must have a different destinations.
All of the "aie.connect" operations must also have a destination which is different from all
of the "aie.masterset" operations in the same switchbox.

Example:
```
%tile = aie.tile(1, 1)
aie.switchbox(%tile) {
  aie.connect<"West" : 0, "Core" : 1>
}
```

Traits: HasParent<SwitchboxOp, ShimMuxOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

### `AIE.connection` (::xilinx::AIE::ConnectionOp)

A logical circuit-switched connection between cores


Syntax:

```
operation ::= `AIE.connection` `(` $source `,` $sourceBundle `:` $sourceChannel `,` $dest `,` $destBundle `:` $destChannel `)` attr-dict
```

The "aie.connection" operation represents a circuit switched connection between two endpoints, usually
"aie.core" operations.  During routing, this is replaced by "aie.connect" operations which represent
the programmed connections inside a switchbox, along with "aie.wire" operations which represent
physical connections between switchboxes and other components.  Note that while "aie.flow" operations
can express partial routes between tiles, this is not possible with "aie.connection" operations.

Example:
  %22 = aie.tile(2, 2)
  %c22 = aie.core(%22)
  %11 = aie.tile(1, 1)
  %c11 = aie.core(%11)
  aie.flow(%c22, "Core" : 0, %c11, "Core" : 1)


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | index
| `dest` | index

### `AIE.core` (::xilinx::AIE::CoreOp)

Declare a core module


Syntax:

```
operation ::= `AIE.core` `(` $tile `)` regions attr-dict
```

This operation represents an AIEngine processor core belonging to a tile.
The region of a CoreOp contains code that gets run on the AIE core.  This code will
typically be outlined into the LLVM dialect, eventually resulting in a binary file
for each core.  The name of this file can be be specified using the 'elf_file'
attribute.

Examples:
```
%tile = aie.tile(1, 1)
%lock11_8 = AIE.lock(%tile, 8)
aie.core(%tile) {
  AIE.useLock(%lock11_8, "Acquire", 1)
  AIE.useLock(%lock11_8, "Release", 0)
  AIE.end
}
```
```
%tile = AIE.tile(3, 3)
AIE.core(%tile) {
  AIE.end
} { elf_file = "core_33.elf" }
```

Interfaces: FlowEndPoint

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.dmaBd` (::xilinx::AIE::DMABDOp)

Declare a dma block descriptor op


Syntax:

```
operation ::= `AIE.dmaBd` `(` `<` $buffer  `:` type($buffer) `,` $offset `,` $len `>` `,` $AB `)` attr-dict
```

This operation describes a block descriptor for DMA operations. In particular, it specifies
what buffer addresss to use, the transfer length, and the buffer type (A or B).

This operation must be used in an MLIR block that lives inside a MemOp's region.
The block descriptor specifies what lock to use and the buffer configuration.

Example:
```
  // this defines a BD that uses lock %lck0 and buffer %buf0
  ^bd5:
    AIE.useLock(%lck, "Acquire", 0)
    AIE.dmaBd(<$buf0 : memref<512xi32>, 0, 512>, 1)
    AIE.useLock(%lck, "Release", 1)
    br ^bd6 // point to the next Block, which is also a different Block Descriptor

  ...

  // this defines a BD that does not use any lock
  ^bd8:
    AIE.dmaBd(<$buf1 : memref<64xi32>, 0, 64>, 0)
```
A DMA channel in a Memory Module can process one block descriptor after another by chaining them.
There are 16 block descriptors per Memory Module. They are shared by four DMA channels.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `offset` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `len` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `AB` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0 whose maximum value is 1

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `buffer` | memref of any type values

### `AIE.dmaBdPacket` (::xilinx::AIE::DMABDPACKETOp)

Enable packet headers for a dma block descriptor


Syntax:

```
operation ::= `AIE.dmaBdPacket` `(` $packet_type `,` $packet_id `)` attr-dict
```

This operation enables packet headers for a block descriptor for DMA operations. In particular, it specifies
the packet type (3-bits) and packet ID (5-bits).

This operation must be used in an MLIR block that lives inside a MemOp's region, and before AIE.dmaBd.
The block descriptor specifies what lock to use and the buffer configuration.

Example:
```
  // this defines a BD that uses lock %lck0 and buffer %buf0
  ^bd5:
    AIE.useLock(%lck, "Acquire", 0)
    AIE.dmaBdPacket(0x4, 0xD)
    AIE.dmaBd(<$buf0 : memref<512xi32>, 0, 512>, 1)
    AIE.useLock(%lck, "Release", 1)
    br ^bd6 // point to the next Block, which is also a different Block Descriptor

```


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `packet_type` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `packet_id` | ::mlir::IntegerAttr | 32-bit signless integer attribute

### `AIE.dmaStart` (::xilinx::AIE::DMAStartOp)

An op to start DMA


Syntax:

```
operation ::= `AIE.dmaStart` `(` $dmaChan `,` $dest `,` $chain `)` attr-dict
```

This operation declares a DMA channel to be used for data transfer.  It usually exists inside
either a MemOp (representing a TileDMA channel), or in a ShimDMAOp (representing a ShimDMA channel).

Example:
```
    AIE.dmaStart("MM2S0", ^bd0, ^end)
  ^bd0:
    AIE.useLock(%lock0, "Acquire", 0)
    AIE.dmaBd(<%buffer : memref<16 x f32>, 0, 16>, 0)
    AIE.useLock(%lock0, "Release", 1)
    br ^bd0
  ^end:
    AIE.end
```

Comceptually, the AIE.dmaStart operation is a terminator that either passes
control to a basic block containing DMA operations (through its first successor)
or to a basic block for another dmaStart, to an AIE.end operation.

Traits: HasParent<MemOp, FuncOp, ShimDMAOp>, Terminator

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `dmaChan` | xilinx::AIE::DMAChanAttr | DMA Channel number

#### Results:

| Result | Description |
| :----: | ----------- |
| `valid` | 1-bit signless integer

#### Successors:

| Successor | Description |
| :-------: | ----------- |
| `dest` | any successor
| `chain` | any successor

### `AIE.debug` (::xilinx::AIE::DebugOp)

Capture a value for debugging


Syntax:

```
operation ::= `AIE.debug` `(` $arg `:` type($arg) `)` attr-dict
```

Output the given value for debugging.  This is primarily used for simulation.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

### `AIE.end` (::xilinx::AIE::EndOp)

end op


Syntax:

```
operation ::= `AIE.end` attr-dict
```

A generic terminator operation for AIE ops' regions.

Traits: Terminator

### `AIE.external_buffer` (::xilinx::AIE::ExternalBufferOp)

Declare a buffer in external memory


Syntax:

```
operation ::= `AIE.external_buffer` $address attr-dict `:` type($buffer)
```

This operation represents a buffer that exists in some physical
location in a device, most likely external memory.

Example:
```
  %buf = AIE.external_buffer 0x200000 : memref<256xi64>
```
This operation represents a buffer living at physical address 0x200000.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `address` | ::mlir::IntegerAttr | 64-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `buffer` | memref of any type values

### `AIE.flow` (::xilinx::AIE::FlowOp)

A logical circuit-switched connection between cores


Syntax:

```
operation ::= `AIE.flow` `(` $source `,` $sourceBundle `:` $sourceChannel `,` $dest `,` $destBundle `:` $destChannel `)` attr-dict
```

The "aie.flow" operation represents a circuit switched connection between two endpoints, usually
"aie.tile" operations.  During routing, this is replaced by "aie.connect" operations which represent
the programmed connections inside a switchbox, along with "aie.wire" operations which represent
physical connections between switchboxes and other components.

Example:
```
  %00 = aie.tile(0, 0)
  %11 = aie.tile(1, 1)
  %01 = aie.tile(0, 1)
  aie.flow(%00, "DMA" : 0, %11, "Core" : 1)
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | index
| `dest` | index

### `AIE.getCascade` (::xilinx::AIE::GetCascadeOp)

An op to read from a cascading stream from a neighboring core


Syntax:

```
operation ::= `AIE.getCascade` `(` `)` attr-dict `:` type($cascadeValue)
```

An op to read from a cascading stream from a neighboring core.

Traits: HasParent<CoreOp>

#### Results:

| Result | Description |
| :----: | ----------- |
| `cascadeValue` | 384-bit integer

### `AIE.getStream` (::xilinx::AIE::GetStreamOp)

An op to read from a stream channel/port of a switchbox


Syntax:

```
operation ::= `AIE.getStream` `(` $channel `:` type($channel) `)` attr-dict `:` type($streamValue)
```

An op to read from a stream channel/port of a switchbox.

Traits: HasParent<CoreOp>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `channel` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `streamValue` | 32-bit float or 32-bit signless integer or 128-bit signless integer

### `AIE.getTile` (::xilinx::AIE::GetTileOp)

Get a reference to an AIE tile


Syntax:

```
operation ::= `AIE.getTile` `(` $col `,` $row `)` attr-dict
```

Return a reference to an AIE tile, given the column and the row of the tile.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `col` | index
| `row` | index

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index

### `AIE.herd` (::xilinx::AIE::HerdOp)

Declare a herd which is a bundle of core organized in a rectangular shape


Syntax:

```
operation ::= `AIE.herd` `[` $width `]` `[` $height `]` attr-dict
```

This operation creates a group of AIE tiles in 2D shape.

Example:
  %herd0 = AIE.herd[1][1] // a single AIE tile. location unknown
  %herd1 = AIE.herd[4][1] // a row of four-AIE tile

The operation can be used in replacement of a TileOp -- in case we want to select a group of
hardware entities (cores, mems, switchboxes) instead of individual entity, and we don't want to
specify their locations just yet. This can be useful if we want to generate parameterizable
code (the column and row values are parameterized).

Example:

  %herd = AIE.herd[2][2] // a herd of 2x2 AIE tiles

  AIE.core(%herd) {
    // all the cores belong to this herd runs the same code
  }

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `width` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `height` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.iter` (::xilinx::AIE::IterOp)

An iter operation


Syntax:

```
operation ::= `AIE.iter` `(` $start `,` $end `,` $stride `)` attr-dict
```

This operation generates index values that can be used with the SelectOp to select a group of tiles
from a herd.

Example:
  %iter0 = AIE.iter(0, 15, 1) // 0, 1, 2, ... , 15
  %iter1 = AIE.iter(2, 8, 2)  // 2, 4, 6

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `start` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `end` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `stride` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.lock` (::xilinx::AIE::LockOp)

Declare a physical lock


Syntax:

```
operation ::= `AIE.lock` `(` $tile `,` $lockID `)` attr-dict
```

This operation creates a physical lock.

Example:
```
  %tile33 = AIE.tile(3, 3)
  %lck = AIE.lock(%tile33, 7)
```
This operation represents a lock that lives in the Memory module of Tile(3, 3) with a lockID of 7

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `lockID` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0 whose maximum value is 15

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.masterset` (::xilinx::AIE::MasterSetOp)

Packet switched input connection


Syntax:

```
operation ::= `AIE.masterset` `(` $destBundle `:` $destChannel `,` $amsels `)` attr-dict
```

A Packet switched connection inside a switchbox.
This operation specifies the configuration for a master port.

Example:
  %a0_m2 = AIE.amsel<0>(2)
  AIE.masterset("Core" : 0, %a0_m2)

The code will configure the master port <"Core" : 0> to use arbiter 0 with msel 2
(see AMSelOp for more details regarding AMSel)

In the current architecture, a master port can only be associated with one arbiter. However,
a master port can be activated by different msels from one arbiter

Example:
  %a1_0 = AIE.amsel<1>(0)
  %a1_1 = AIE.amsel<1>(1)
  %a2_3 = AIE.amsel<2>(3)

  AIE.masterset("West" : 2, %a1_0, %a2_3) // this is illegal, please don't do this
  AIE.masterset("West" : 3, %a1_0, %a1_1) // this is OK

Traits: HasParent<SwitchboxOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `amsels` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.mem` (::xilinx::AIE::MemOp)

Declare a memory op


Syntax:

```
operation ::= `AIE.mem` `(` $tile `)` regions attr-dict
```

This operation creates a Memory module that belongs to a tile.
The region of a MemOp is used to setup the DMAs and Block Descriptors.
See DMAOp and DMABdOp for more concrete examples.

Interfaces: CallableOpInterface, FlowEndPoint

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.memcpy` (::xilinx::AIE::MemcpyOp)

A memcpy op


Syntax:

```
operation ::= `AIE.memcpy` $tokenName `(` $acqValue `,` $relValue `)` `(`
              $srcTile `:` `<` $srcBuf `,` $srcOffset `,` $srcLen `>` `,`
              $dstTile `:` `<` $dstBuf `,` $dstOffset `,` $dstLen `>` `)`
              attr-dict `:` `(` type($srcBuf) `,` type($dstBuf) `)`
```

This operation defines a logical data transfer of a buffer from a source tile to another buffer
from a destination tile.

This operation should be lowered to Mem ops with DMA setup and Flow ops for routing data from
the source tile to the dest. tile.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `tokenName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute
| `acqValue` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `relValue` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `srcOffset` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `srcLen` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `dstOffset` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `dstLen` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `srcTile` | index
| `srcBuf` | memref of any type values
| `dstTile` | index
| `dstBuf` | memref of any type values

### `AIE.plio` (::xilinx::AIE::PLIOOp)

Declare an interface to the PL


Syntax:

```
operation ::= `AIE.plio` `(` $col `)` attr-dict
```

An interface to the PL.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `col` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.packet_dest` (::xilinx::AIE::PacketDestOp)

A destination port


Syntax:

```
operation ::= `AIE.packet_dest` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

A object representing the destination of a packet-switched flow. This must exist
within an [AIE.packet_flow](#aiepacketflow-aiepacketflowop) operation. The destination
Must be unique within a design.

See [AIE.packet_flow](#aiepacketflow-aiepacketflowop) for an example.

Traits: HasParent<PacketFlowOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `bundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

### `AIE.packet_flow` (::xilinx::AIE::PacketFlowOp)

Packet switched flow


Syntax:

```
operation ::= `AIE.packet_flow` `(` $ID `)` regions attr-dict
```

A logical packet-switched flow between tiles.  During place and
route, this is replaced by MasterSets and PacketRules inside
switchboxes.

Example:
```
  %01 = AIE.tile(0, 1)
  AIE.packet_flow(0x10) {
    AIE.packet_source<%01, "Core" : 0>
    AIE.packet_dest<%01, "Core" : 0>
  }
```

Traits: SingleBlockImplicitTerminator<EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `ID` | ::mlir::IntegerAttr | 8-bit signless integer attribute

### `AIE.rule` (::xilinx::AIE::PacketRuleOp)

Packet switched routing rule


Syntax:

```
operation ::= `AIE.rule` `(` $mask `,` $value `,` $amsel `)` attr-dict
```

This operation defines a matching rule and a destination for packet-switched
connections in a switchbox.  Routing is based on the ID field of packet arriving on the
matching port of the containing [AIE.packetRules](#aiepacketrules-aiepacketrulesop).
The ID is first bitwise-AND'd with the mask and then checked for equality with the given ID.
It is routed to arbiter and master set associated with the first matching entry.

Example:
  LUT ID  |  Mask     | ID          | Arbiter | Msel
  ---     | ---       | ---         | ---     | ---
  0       |  5'b11111 | 5'b00010    | 4       | 1
  1       |  5'b11011 | 5'b00001    | 3       | 2
  2       |           |             |         |
  3       |           |             |         |

If a packet flow that has an ID of 2, it will be directed to the arbiter 4 with msel 1,
If a packet flow that has an ID of 1 or 5, it will be directed to the arbiter 3 with msel 2,

We encapsulate the configuration table as follows:
Example:
```
  %a4_1 = AIE.amsel<4>(1)
  %a3_2 = AIE.amsel<3>(2)

  AIE.packetRules("Core" : 0) {
    AIE.rule(0x1F, 0x2, %a4_1)
    AIE.rule(0x1B, 0x1, %a3_2)
  }
```

Traits: HasParent<PacketRulesOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `mask` | ::mlir::IntegerAttr | 8-bit signless integer attribute
| `value` | ::mlir::IntegerAttr | 8-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `amsel` | index

### `AIE.packetrules` (::xilinx::AIE::PacketRulesOp)

Packet switched routing rules


Syntax:

```
operation ::= `AIE.packetrules` `(` $sourceBundle `:` $sourceChannel `)` regions attr-dict
```

This operation defines packet-switched routing configuration for packets entering a switchbox.
It references a port of the containing swithcbox, which be unique among other packetRules
operations and [AIE.connect]($aieconnect-aieconnectop) operations in the containing switchbox.
It contains a region of up to 4 [AIE.rule](#aierule-aiepacketruleop) operations.

See [AIE.rule](#aierule-aiepacketruleop) for an example.

Traits: SingleBlockImplicitTerminator<EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

### `AIE.packet_source` (::xilinx::AIE::PacketSourceOp)

A sourceport


Syntax:

```
operation ::= `AIE.packet_source` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

A object representing the destination of a packet-switched flow. This must exist
within an [AIE.packet_flow](#aiepacketflow-aiepacketflowop) operation.

See [AIE.packet_flow](#aiepacketflow-aiepacketflowop) for an example.

Traits: HasParent<PacketFlowOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `bundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

### `AIE.place` (::xilinx::AIE::PlaceOp)

A place operation that specifies the relative placement (XY) of one herd to another


Syntax:

```
operation ::= `AIE.place` `(` $sourceHerd `,` $destHerd `,` $distX `,` $distY `)` attr-dict
```

A place operation that specifies the relative placement (XY) of one herd to another.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `distX` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `distY` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `sourceHerd` | index
| `destHerd` | index

### `AIE.putCascade` (::xilinx::AIE::PutCascadeOp)

An op to write to a cascading stream from a neighboring core


Syntax:

```
operation ::= `AIE.putCascade` `(` $cascadeValue `:` type($cascadeValue) `)` attr-dict
```

An op to write to a cascading stream from a neighboring core.

Traits: HasParent<CoreOp>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `cascadeValue` | 384-bit integer

### `AIE.putStream` (::xilinx::AIE::PutStreamOp)

An op to write to a stream channel/port of a switchbox


Syntax:

```
operation ::= `AIE.putStream` `(` $streamValue `:` type($streamValue) `,` $channel `:` type($channel) `)` attr-dict
```

An op to write to a stream channel/port of a switchbox.

Traits: HasParent<CoreOp>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `channel` | integer
| `streamValue` | 32-bit float or 32-bit signless integer or 128-bit signless integer

### `AIE.route` (::xilinx::AIE::RouteOp)

A route operation that routes one herd to another


Syntax:

```
operation ::= `AIE.route` `(` `<` $sourceHerds `,` $sourceBundle `:` $sourceChannel `>` `,`
              `<` $destHerds   `,` $destBundle   `:` $destChannel   `>` `)` attr-dict
```

A route operation that routes one herd to another.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `sourceHerds` | index
| `destHerds` | index

### `AIE.select` (::xilinx::AIE::SelectOp)

A select operation


Syntax:

```
operation ::= `AIE.select` `(` $startHerd `,` $iterX `,` $iterY `)` attr-dict
```

This operation selects a group of tiles based on the selected indices.

Example:

  %herd = AIE.herd[4][4] // a herd of 4x4 tiles

  %ix = AIE.iter(0, 4, 1) // 0, 1, 2, 3
  %iy = AIE.iter(0, 1, 1) // 0

  %sub_herd = AIE.select(%herd, %ix, %iy)

The SelectOp in the above example will select the tiles %herd[0][0], %herd[1][0],
%herd[2][0], %herd[3][0] (the first column of the herd).

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `startHerd` | index
| `iterX` | index
| `iterY` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.shimDMA` (::xilinx::AIE::ShimDMAOp)

Declare a DMA in the PL shim


Syntax:

```
operation ::= `AIE.shimDMA` `(` $tile `)` regions attr-dict
```


Interfaces: FlowEndPoint

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.shimmux` (::xilinx::AIE::ShimMuxOp)

Declare a switch in the PL shim


Syntax:

```
operation ::= `AIE.shimmux` `(` $tile `)` regions attr-dict
```

This operation represents the additional interconnect that is part of a shim interface tile.
Like the "AIE.switchbox" operation, "AIE.shimMux" is configured
by code in its region, but can only contain connect operations

Example:
```
%tile = aie.tile(1, 1)
aie.shimmux(%tile) {
  aie.connect<"North" : 0, "DMA" : 1>
}
```

Traits: SingleBlockImplicitTerminator<EndOp>

Interfaces: Interconnect

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.shimswitchbox` (::xilinx::AIE::ShimSwitchboxOp)

Declare a switch in the PL shim


Syntax:

```
operation ::= `AIE.shimswitchbox` `(` $col `)` regions attr-dict
```

A switch in the Shim.
AXI-Stream Master Ports AXI-Stream Slave Ports
6 Ports to North (Core Tile) 4 Ports from North (Core Tile)
4 Ports to West 4 Ports from West
4 Ports to East 4 Ports from East
6 Ports to South(DMA, NoC I/F, PL I/F) 8 Ports from South (DMA, NoC I/F, PL I/F)
2 Ports to FIFOs 2 Ports from FIFOs
1 Port for control packet for Shim register access
1 Port for response to access for Shim registers
1 Port for trace packet from Shim


Traits: SingleBlockImplicitTerminator<EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `col` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.switchbox` (::xilinx::AIE::SwitchboxOp)

Declare a switch


Syntax:

```
operation ::= `AIE.switchbox` `(` $tile `)` regions attr-dict
```

This operation represents the switchbox that is part of a tile.  A switchbox is configured
by code in its region, representing various connections

Example:
```
%tile = aie.tile(1, 1)
aie.switchbox(%tile) {
  aie.connect<"West" : 0, "Core" : 1>
}
```

Traits: SingleBlockImplicitTerminator<EndOp>

Interfaces: Interconnect

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.tile` (::xilinx::AIE::TileOp)

Declare an AIE tile


Syntax:

```
operation ::= `AIE.tile` `(` $col `,` $row `)` attr-dict
```

This operation creates an AIE tile in the AIE array. We specify what the column and the row of the tile.

A tile encompasses core module (CoreOp), memory module (MemOp), stream switch (SwitchboxOp),
memory buffer (BufferOp), and lock (LockOp).

A tile is a logical abstraction. We use a tile to establish an ownership of a hardware entity
to it.
Note that row 0 of the Tile array is different from other rows, since it models the shim interface between
the AIE array proper and the PL.  The South-West/Lower Right most core exists in Tile(0,1)

Interfaces: FlowEndPoint

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `col` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0
| `row` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index

### `AIE.token` (::xilinx::AIE::TokenOp)

Declare a token (a logical lock)


Syntax:

```
operation ::= `AIE.token` `(` $value `)` attr-dict
```

This operation creates a logical lock. We use Symbol so that it can be referenced globally.
Unlike phsical locks, logical locks are unlimited, and we can specify any integer value
associated with a lock. The logical lock is used to manually specify the dependence of tasks, or
core executions.

The operation can also be generated automatically if the Dependence Analysis can be leveraged.

Example:
  AIE.token(0) {sym_name = "token0"} // Declare token0 with initial value of 0

  ...

  AIE.useToken @token0("Acquire", 0) // acquire token0 if its value is 0

  ...

  AIE.useToken @token0("Release", 5) // release token0 and set its value to 5


Interfaces: Symbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::IntegerAttr | 32-bit signless integer attribute

### `AIE.useLock` (::xilinx::AIE::UseLockOp)

acquire/release lock op


Syntax:

```
operation ::= `AIE.useLock` `(` $lock `,` $action `,` $value ( `,` $blocking^ )? `)` attr-dict
```

This operation uses a lock. A lock can be acquired with a value, or release with a value.
This should be understood as a "blocking" operation.  This lock must appear in a parent op
where the tile can be determined (A CoreOp, a ShimDMAOp, or a MemOp).

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0 whose maximum value is 2
| `action` | xilinx::AIE::LockActionAttr | lock acquire/release
| `blocking` | xilinx::AIE::LockBlockingAttr | lock operation is blocking

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lock` | index

### `AIE.useToken` (::xilinx::AIE::UseTokenOp)

acquire/release a logical lock


Syntax:

```
operation ::= `AIE.useToken` $tokenName `(` $action `,` $value `)` attr-dict
```

This operation uses token (logical lock). A logical lock can be acquired or released with a value.
Similar to UseLockOp, this operation can be understood as "blocking" op.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `tokenName` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute
| `value` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `action` | xilinx::AIE::LockActionAttr | lock acquire/release

### `AIE.wire` (::xilinx::AIE::WireOp)

A bundle of physical wires between components


Syntax:

```
operation ::= `AIE.wire` `(` $source `:` $sourceBundle `,` $dest `:` $destBundle `)` attr-dict
```

The "aie.wire" operation represents a physical set of connections between components in a Versal device.
Typically, these components are switches, represented by an "aie.switchbox" operation, and tiles,
represented by an [aie.tile](#aietile-aietileop) operation.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | index
| `dest` | index

